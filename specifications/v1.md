# `.xff` specification v1

> [!note]
> ***This version is not yet finalized.***

This specification differs significantly from version 0 and cannot parse v0 files.

`.xff` stands for `xqhares file format` or `xqhared file format`, pronounced `squares file format` or `squared file format`.
Alternatively, it could be called `xtended file format` or `extended file format`.

The binary data in `.xff` is encoded in ASCII, specifically Windows-1252.
Any mention of ASCII should be understood to be referring to Windows-1252 specifically. 
[See the reference table here.](ascii-reference.md)

`.xff` is a very simple format. It uses a small subset of ASCII control characters to wrap arbitrary or ASCII data.
If used with ASCII data only, it can hold any String, Number or Control character and any amount of them.
The `.xff` format has no set maximum file size.

A `.xff`file starts with one byte (8 bits) of data, encoding the current version of the `.xff` specification.
The version number starts at 0 and increases by 1 each time a new version is added.
Any implementation of this specification should be able to read any version of the specification, but may choose to only support a specific set of versions or version.

This specification has defined eight value types that can be stored in the `.xff` file.
They are:

1. Strings
2. Numbers
3. General Data
4. Command characters
5. Arrays
6. Objects
7. Boolean's
8. Null

![Chart of the composition of a `.xff` file in token form.](../pictures/xff_v1-main-chart.png)

## Length attribute

Every value type except `Booleans` and `Null` has a length attribute.

The length attribute is split in two parts:
First the byte length of the length, then as many bytes as indicated by the first byte containing the length.

If for example the first byte is set to one, the length is the following byte.
The first byte can never be 0.

All length data is encoded in binary using the Little-Endian byte-ordering.

> [!note]
> This means that the largest possible length is a number 255 bytes long. That is larger than there are atoms in the observable universe.
> With an 8 byte long number you can save 1 petabyte of data.

![Chart of the composition of the length in token form.](../pictures/xff_v1-len-chart.png)

## Strings and numbers
The general makeup of a `String` and `Number` is the same as in version 0.

Strings and numbers have to be encoded in ASCII, or they have to be treated like any other escaped data.
An entry can be of any length.

The command character codes 8 through 13 are permissible in a `String` without the need to be escaped.
No command characters should be used if a `Number` is represented.

`STX` and `ETX` are the start and end of any text data or numerical data encoded in ASCII.
The `ETX` also provides an inbuilt check of the length of the data to validate it.
The text wrapped by it should be returned as a fully decoded `String` or appropriate `Number`.
The difference between `String` and `Number` is in that a valid `Number` is any valid number as according to the 2nd Edition of `ECMA-404` from December 2017, and any different content is a `String`.

![Chart of the composition of a character in token form.](../pictures/xff_v0-char-chart.jpeg)

## General data
Any data following `DLE`, until another `DLE` is encountered, is considered part of a unified data-stream. This makes it possible to save any kind of data inside.

The closing `DLE` is not part of the data, but it serves as a check of the length of the data to validate it.
The data inside the escape should be stored as-is, meaning that the data inside it could be UTF-8 encoded or JPEG encoded for example.

## Command characters
All command characters should be returned to the caller, and any non-command characters should error.
To make all characters available to the caller, any command character should be escaped with `ESC`, and `ESC` should be escaped with `ESC` too.
This requirement makes it so that the only way to encode a singular `ESC` is with `ESC` `ESC` `ESC` `ESC`. Using 4 byte to encode one byte of data. 
Command characters should be saved together, if they are followed by another command character.

`EM` is the end of the `.xff` file and serves as a check that the entire `.xff` file has been read.

> [!important]
> Because of the way I decided to design the `.xff` specification, the control characters, as they are called in the ASCII standard, are not all valid command characters.
> Some non control characters are also valid command characters.

![Chart of the composition of a command character in token form.](../pictures/xff_v0-cmd-char-chart.jpeg)

## Array
An array may consist of any number of values of any type.
The elements are separated by `ETB`.
The array may be closed with a trailing `ETB` or without.

![Chart of the composition of an array in token form.](../pictures/xff_v1-array-chart.png)

## Object
An object may consist of any number of key-value pairs.
The keys have to be strings, the values can be any type.
The elements are enclosed by `GS`, the key and the value are separated by `RS`.
The key-value pairs are separated by `US`.
The object may be closed with a trailing `US` or without.

![Chart of the composition of an object in token form.](../pictures/xff_v1-object-chart.png)

## Boolean
A boolean can be either `true` or `false`.
Represented by the ASCII control characters `DC1` and `DC3`, or `XON` and `XOFF` respectively.

![Chart of the composition of a boolean in token form.](../pictures/xff_v1-boolean-chart.png)

## Nul / Null / None
A null value can be represented by the ASCII control character `NUL`.




## Musings about a future version 1

- A way to represent arrays of data in byte form directly in `.xff` would be nice.
    - I am continuously running into the need to at least be able to store key-value pairs in `.xff` files.
- Some kind of optional metadata for any data, be it strings, data or even command characters.
- Maybe integrate an object store directly, solving all of the above?
- Think about what to do with features, implement version dependent read and write functions?
- Everything gets a length attribute. For performance.
    - Variable amount of length-bytes by prepending a single byte encoding the length of the length-bytes. Maximum length possible: 1.2E614 bytes - Length of a Petabyte: 1e15 which needs only 8 bytes.

## Note for version 255 - move to v2 when v1 done
- Add a second version byte to the start of the file, easy 256 more versions right there!
    - Fuck it, 2 more version bytes for 65.536 more versions! If I ever reach 255 I'll need them!
